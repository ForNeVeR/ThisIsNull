# Когда `this == null`: невыдуманная история из мира CLR

Довелось не так давно отлаживать код, который падал с `NullReferenceException` вот на таком "ровном месте" в следующем фрагменте C#-кода:

```csharp
	public class Tester {
		public string Property { get; set; }
		public void Foo() {
			this.Property = "Some string";
		}
	}
```

Да-да, вот на этой самой строчке с присвоением свойства падал `NullReferenceException`. Что за дела, думаю - неужели компилятор перестал проверять наличие экземпляра перед вызовом экземплярных методов?

Как оказалось - в некотором роде **да, перестал**. Правда, и компилятор оказался не тем, за кого себя выдаёт, да и проверки не те... Подробнее - под катом.

---

Для тех, кто не привык работать с C#, поясню цепочку своих размышлений по этому поводу. Итак, у нас есть экземплярный метод `Foo` и экземплярное же свойство `Property`. Некто вызвал метод `Foo`, но на обращении к `this.Property` у нас обнаружилась _некая неожиданность_, которая привела к генерации рантаймом исключения `NullReferenceException`.

В обычной ситуации это могло бы означать, что у нас в этом месте `this == null`, и поэтому строка `this.Property` не может получить доступ к свойству. Но для программиста на C# это звучит как нонсенс - ведь был же как-то вызван метод `Foo`,  то есть экземпляр на самом деле у кого-то был! Как можно было вызвать метод у `null`?

Но стектрейс-то вот он, указывает на эту строку! Начинаем сомневаться во всём подряд, включая собственную вменяемость, и пишем следующую тестовую программу:

```csharp
static class Program {
    static void Main() {
        Tester t = null;
        t.Foo();
    }
}
```

Компилируем, выполняем - да, программа падает с `NullReferenceException` на строке `t.Foo();`, но в метод `Foo` не заходит. Это что же получается, при каких-то условиях рантайм забыл выполнить проверку на `null`?

На самом деле, нет. Виноват во всём происходящем, конечно, не рантайм, а компилятор. Однако не компилятор C#, а компилятор C++/CLI, с помощью которого был скомпилирован код, вызывающий метод `Foo` (да-да, участие C++/CLI в этой истории сразу бы вызвало много подозрений, и я изначально специально об этом умолчал, чтобы было поинтереснее :).

Продолжаем эксперименты, пишем такую же программу на C++/CLI:

```cpp
int main() {
   Tester ^t = nullptr;
   t->Foo();
}
```

Компилируем, запускаем - бац! Падает `NullReferenceException` _внутри_ метода `Foo`. То есть он каким-то чудом был вызван.

Что же происходит? У нас в руках две совершенно одинаковые программы на разных языках. Предполагаем, что они должны скомпилироваться в практически одинаковый (ну или хотя бы похожий) байткод, если компиляторы обоих языков следуют спецификациям CLI. Начинаем разбираться уже с байткодом. Берём ildasm и разбираем код программы на C#: